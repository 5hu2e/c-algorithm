## 第三章:贪心

### 贪心的概念

* 定义: 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。

* 基本要素: 
    * 贪心选择性质:指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。）
    * 最优子结构性质:当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
* 贪心与动态规划的区别：
    * 不同：
        * 贪心：局部最优出发；动态规划:整体出发。
        * 贪心：只需要保留当前解的前一个解；动态规划：保留全部解。
    * 相同:
        * 贪心算法和动态规划算法都要求问题具有最优子结构性质。 


### 活动安排问题

* 问题描述:设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si < fi。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交,则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。

* 思考:
    * 按照一定的顺序选择相容活动，并能够安排尽量多的活动。有以下两种看似合理的贪心策略：
    * (1)最早开始时间：这样可以增大资源的利用率。 
    * (2)最早结束时间：这样可以使下一个活动尽早开始。
    * 由于活动占用资源的时间没有限制，因此直观上，按最早结束时间这种策略选择相容活动可以留下尽可能多的时间安排更多活动。

| 活动编号 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 |
| :------: | :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:|
| 开始时间 | 1  | 3  | 0  | 5  | 3  | 5  | 6  | 8  | 8  | 2  | 12 |
| 结束时间 | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 15 |

* 贪心选择：
    * 从头开始依次选择，第一个活动一定进行选择，以前一个活动的结束时间end最为参考标准，如果下一个活动的开始时间start>=end，那么就将其纳入相容活动集合，否则不断向后，直至结束。

* 结构体排序
```c
typedef struct {
    int i;
    int j;
}node;
node arr[maxN];
int n; 

bool cmp1(node a, node b){
//调用这个函数会使得数组按照i从小到大进行排序
    return a.i < b.i;
}
sort(arr, arr + n, cmp1);

bool cmp(node a, node b){
//调用这个函数会使得数组按照i从大到小进行排序
    return a.i > b.i;
}
sort(arr, arr + n, cmp2);
```

* 活动安排问题代码

```c
#include <iostream>
#include <algorithm> // 包含 std::sort
using namespace std;

typedef struct {
    int id;    // 活动的唯一标识符
    int s;     // 活动的开始时间
    int f;     // 活动的结束时间
    int flag;  // 标记该活动是否被选中
} activity;

// 比较函数，用于按结束时间排序
bool cmp(activity a, activity b) {
    return a.f < b.f; // 按结束时间升序排列
}

// 函数：选择活动
void func(activity arr[], int n) {
    // 按结束时间排序
    sort(arr, arr + n, cmp);

    int endtime = 0; // 记录上一个被选中活动的结束时间

    // 选择活动
    for (int i = 0; i < n; i++) {
        if (arr[i].s >= endtime) { // 如果当前活动的开始时间大于等于上一个活动的结束时间
            arr[i].flag = 1; // 标记为被选中
            endtime = arr[i].f; // 更新结束时间
        } 
    }

    // 输出被选中的活动的 ID
    for (int i = 0; i < n; i++) {
        if (arr[i].flag) 
            printf("%d ", arr[i].id); // 打印 ID
    }
}

```

### 最优装载问题

* 问题描述:
    * 有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。 最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。

* 贪心选择:
    * 集装箱的重量越小我们就越先装入，即按照重量从小到大进行排序

```c
typedef struct {
    int id; // 盒子的唯一标识符
    int w;  // 盒子的重量
    int flag; // 用于标记是否被选中
} box;

// 比较函数，用于按重量升序排列
bool cmp(box a, box b) {
    return a.w < b.w;
}

// 函数：选择不超过容量 c 的盒子
void func(box arr[], int n, int c) {
    sort(arr, arr + n, cmp); // 按重量升序排序

    int weight = 0; // 当前总重量
    for (int i = 0; i < n; i++) {
        if (weight + arr[i].w <= c) { // 检查是否能放入当前盒子
            arr[i].flag = 1; // 标记为被选中
            weight += arr[i].w; // 更新总重量
        } else {
            break; // 超过容量，停止选择
        }
    }
    for (int i = 0; i < n; i++) {
        if (arr[i].flag) {
            printf("%d ", arr[i].id); // 输出选中盒子的 ID
        }
    }
}


```

### 哈夫曼树
- 参考 https://blog.csdn.net/chenlong_cxy/article/details/117929139
* 哈夫曼树的基本概念
    * 路径: 在一棵树中，从一个结点往下可以达到的结点之间的通路，称为路径
    * 路径长度: 某一路径所经过的“边”的数量，称为该路径的路径长度
    * 带权路径长度: 若将树中结点赋给一个带有某种含义的数值，则该数值称为该结点的权。从根结点到该结点之间的路径长度与该结点的权的乘积，称为该结点的带权路径长度。
    * 树的带权路径长度: 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。

* 什么是哈夫曼树
    * 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，则称该二叉树为哈夫曼树，也被称为最优二叉树。

* 贪心选择
    * 根据树的带权路径长度的计算规则，我们应该尽可能地让权值大的叶子结点靠近根结点，让权值小的叶子结点远离根结点，这样便能使得这棵二叉树的带权路径长度达到最小。

* 哈夫曼树的构造
    * 1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。
    * 2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
    * 3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
    * 4）重复步骤2）和3），直至F中只剩下一棵树为止。

* 总结一下: 
    * 构建哈夫曼树就是反复选择两个最小的元素进行合并，直到只剩下一个元素为止。（贪心策略）

```c
#define N 30
#define M 2*N - 1;
typedef struct HTNode{
    double weight;  //权值
    int parent;  //父节点
    int lc, rc;  //左右孩子
}HTNode, HuffmanTree[M+1];

//在ht[1]至ht[n]的内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2, s1 < s2
void Select(HuffmanTree ht, int n, int &s1, int &s2){
    int min1 = MAX, min2 = MAX;
    s1 = 0, s2 = 0;
    for(int i = 1; i <= n; i++){
        if(ht[i].parent == 0){  //检查其父结点是否为 0（即它尚未被合并到其他结点中）
            if(ht[i].weight < min1){   //  w < min1
                min2 = min1;      //当前结点的权重小于 min1，则更新 min2 为 min1，
                s2 = s1;            //同时更新 s2 为 s1
                min1 = ht[i].weight;   //然后将 min1 更新为当前结点的权重
                s1 = i;                //并将 s1 更新为当前结点的索引。
            }
            else if(ht[i].weight < min2){ //  当前结点的权重介于 min1 和 min2 之间（即小于 min2）
                min2 = ht[i].weight;   //      则更新 min2 和 s2。
                s2 = i;
            } 
        }
    }
}

//创建huffman树，w[]存放n个权值
void CreateHuff(HuffmanTree ht, int w[], int n){
    int m = 2 * n - 1; //哈夫曼树总节点数
    for(int i = 1; i <= n; i++){
        ht[i].weight = w[i];
        ht[i].parent = 0;
        ht[i].lc = 0;
        ht[i].rc = 0;
    }
    for(int i = n+1; i <= m; i++){
        ht[i].weight = 0;
        ht[i].parent = 0;
        ht[i].lc = 0;
        ht[i].rc = 0;
    }
//初始化结束，开始合并
    for( int i = n+1; i <= m; i++){   //创建非叶结点，建哈夫曼树
        Select(ht, i-1, s1, s2);        //在ht[1]至ht[i-1]的范围内选择两个parent为0
                                        //且weight最小的结点，其序号分别赋给s1，s2
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[i].lc = s1;
        ht[i].rc = s2;
        ht[s1].parent = i;
        ht[s2].parent = i;
    }
}

```


### 单源最短路径

* 题目描述：给定一个图（有向图或者无向图都可以），如何计算图上指定结点到其他所有结点的最短距离？(单源点的最短路径问题)
* 单源点的最短路径问题：给定带权有向图G和源点v0, 求从v0到G中其余各顶点的最短路径。
* 松弛操作 : 
    * 假设A -> B的路线距离为 x, B -> C的路线距离为y，如果直接从A -> C的距离z > x + y，那么先走A -> B，再走B -> C，要比直接从A -> C短. 因此，我们可以借助B缩短AC之间的距离。

* 贪心策略
    * 1. 从起点出发，选择一个距离起点距离最小的、未被标记的顶点；
    * 2. 利用该顶点，对起点到其他所有的顶点进行松弛操作；
    * 3. 标记该顶点已经是最优，重复1、2操作直到没有顶点可以选择。

* 算法思想：
    * 1. 设有两个顶点集合S和T，集合S中存放图中已找到最短路径的顶点，集合T存放图中剩余顶点。初始状态时，集合S中只包含源点v0；
    * 2. 不断从集合T中选取到顶点v0路径长度最短的顶点vi并入到集合S中。
    * 3. 集合S每并入一个新的顶点vi，如果源点v0通过中转顶点vi到集合T中顶点的路径更短，就更新源点v0到集合T中顶点的最短路径长度值。
    * 4. 重复2,3操作，直到集合T的顶点全部并入到S中为止

```c
//Dijkstra算法是解决单源最短路问题的贪心算法，其算法基本思想是:
//    设置顶点集合S并不断的作贪心选择来扩充这个集合
const int maxVexNum = 30; // 最大顶点数量
const int maxInt = 1e4 + 1; // 定义一个很大的值，表示无穷大

// 图的结构体定义
typedef struct {
    int vexNum;  // 顶点数量
    int Edge[maxVexNum][maxVexNum]; // 邻接矩阵
} MGraph;

int visited[maxVexNum];  //标记数组，是否已选进顶点集合
int path[maxVexNum];     //路径数组，记录该点的前一个顶点
int length[maxVexNum];   //长度数组，记录该点到源点V0的距离

void Dijkstra(MGraph G, int v){

    //初始化
    for(int i = 0; i < G.vexNum; i++){
        length[i] = G.Edge[v][i];  // 源点 v 到各个节点的距离
        visited[i] = 0;     // 初始化所有节点未访问
        if(length[i] < maxInt)  path[i] = v;    // 记录前驱节点
        else path[i] = -1;    // maxInt既V0到该顶点之间没有直接路径
    }
    visited[v] = 1;     //v0 加入集合
    path[v] = -1;   // 源点的前驱节点设置为 -1
    length[v] = 0;  // 源点到自己的距离为 0

    // Dijkstra 主循环
    for(int i = 1; i < G.vexNum; i++){
            //遍历n-1次 每次选取一个顶点
        int minm = maxInt;  // 初始化最小距离为无穷大
        int minVex = -1;    // 记录离源点最近的节点
        //每次遍历一轮 查看当前未加入节点，离v0最短的 选入顶点集合
        for(int j = 0; j < G.vexNum; j++){
            if(!visited[j] && length[j] < minm){
                minm = length[j];
                minVex = j;  // 记录最小距离的节点
            }
        }
        visited[minVex] = 1;
        //离v0最短的节点已入集合，开始修改length数组
        //是否有v0源点通过minVex到达的顶点 比 V0直接到达更近
        for(int j = 0; i < G.vexNum; j++){
            if(!visited[j] && dist[minVex] + G.Edge[minVex][j] < length[j])
                //v0->minVex->j 比 当前 v0->j 更近  修改路径数组及长度数组
                length[j] = dist[minVex] + G.Edge[minVex][j];
                path[j] = minVex;
        }
    }
```

