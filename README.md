# c计算机算法设计与分析(王晓东)

个人的计算机算法设计与分析记录(c语言)


# 计算机算法设计与分析

## 第二章 : 动态规划

### 动规的概念
* 定义：需要求解问题可以分为多个子问题，若最优解可由子问题的最优解推出，则可先求子问题的最优解，再构造原问题的最优
解。若子问题重复出现，则将其记忆化存储，便于求解相相同子问题，从而减少计算量，最后自底向上，从最终子问题向原问题逐步求解。

* 动规的基本要素：
    * 最优子结构：指问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
    * 重叠子问题：在解决原问题的过程中，每次产生的子问题并不总是新问题，有些子问题被重复计算。

* 动规算法设计步骤：
    * (1)找出最优解的性质，并刻划其结构特征。
    * (2)递归地定义最优值。
    * (3)以自底向上的方式计算出最优值。
    * (4)根据计算最优值时得到的信息，构造最优解。

* 动规与分治的关系：
    * 相同：动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题
    * 区别：1.分治法独立的子问题，而动态规划的子问题不是互相独立的。2.分治是自顶向下的，而动规是自底而上的

* 状态转移方程：
    * 需某一状态下以及该状态下的决策与下一状态之间的函数关系称为状态转移方程，其中函数可以求的是收益、成本或者距离等，求最优解时所对应的函数称之为最优函数。

* 决策：指决策者在处于某一阶段的某种状态时面对下一阶段的状态做出的选择或者决定

* 状态：描述当前决策过程的特征的量，可以是数量、字符等

### 矩阵连乘

* 问题描述：
给定n个矩阵{A1，A2...An}，其中Ai和Ai+1是可乘的，考察这n个矩阵的连乘积A1*A2*...*An。
由于矩阵的乘法满足结合律，故计算矩阵的连乘积有许多不同的计算次序，而不同的计算次序，所需要计算的连乘次数也是不同
的，求解连乘次数最少的矩阵连乘最优次序。

* 题目求解步骤：
    * 假设最优次数从Ak分开，那么总体的次数就可以得到如下的求法
    ```
    A1*A2*.............*Ak  => T1（i*j）
    Ak+1*Ak+2*.............*An => T2（j*l）
    A1*A2*...*An => T1+T2+i*j*l
    ```
    * 递归的向下继续分，可以得到同样的结果
    * 分解最优解的结构：
    ```
    • 对于矩阵连乘问题，最优解就是找到一种加括号方法，使得计算次数最少。
    • 令m[i][j]表示第i个矩阵至第j个矩阵这段的最优解（这段的最少计算次数）。
    • 将矩阵连乘积记为A[i:j] ，这里i<=j，假设这个最优解在第k处断开，i<=k<j，则A[i:j]是最优的，那么A[i,k]和A[k+1:j]也是相应矩阵连乘的最优解。
    ```
    * 状态转移方程：
    ```
    • 设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] 。
    • 当i=j时，m[i,j]=0;(表示只有一个矩阵,没有和其他矩阵相乘,故乘的次数为0)
    • 当i<j时，m[i,j]=min{m[i,k]+m[k+1,j] +(pi-1)*pk*pj} ,其中 i<=k<j（表示左右乘出来的矩阵最后相乘）
    • 计算最优值
    对于1≤i≤j≤n不同的有序对(i,j) 对于不同的子问题，因此不同子问题的个数最多只有o(n*n).但是若采用递归求解的话，许多子问题将被重复求解，
    所以子问题被重复求解，这也是适合用动态规划法解题的主要特征之一。
    ```
    * 用一个一维度数组p保存
        * Ai:  pi-1 为行， pi为列

| 矩阵 | A1 | A2 | A3 | A4 | A5 | A6 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 行*列 | 30*35 | 35*15 | 15*5 | 5*10 | 10*20 | 20*25 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 下标   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| 值 | 30 | 35 | 15 | 5 | 10 | 20 | 25 |
---



* A[i:j]完整表格
    * 以A[1:3]举例
        * 1.A1（A2A3）=2625+30*35*5=7875
        * 2.（A1A2）A3=15750+30*15*5=18000
        * A[1:3] = min = 7875

---

|   | 1     | 2     | 3     | 4     | 5     | 6     |
|---|-------|-------|-------|-------|-------|-------|
| 1 | 0     | 15750 | 7875  | 9375  | 11875 | 15125 |
| 2 | 0     | 0     | 2625  | 4375  | 7125  | 10500 |
| 3 | 0     | 0     | 0     | 750   | 2500  | 5375  |
| 4 | 0     | 0     | 0     | 0     | 1000  | 3500  |
| 5 | 0     | 0     | 0     | 0     | 0     | 5000  |
| 6 | 0     | 0     | 0     | 0     | 0     | 0     |
---

* 矩阵连乘代码
```c
void func(){
    //初始化
    for(int i = 1; i <= n; i++)
        m[i][i] = 0;
    //len 表示要矩阵连乘的长度
    for(int len = 2; len <= n; len++){
        //枚举长度为len的矩阵的起点的下标
        for(int start = 1; start <= n-len+1; start++){
            int end = start + len - 1; //end位置下标
            m[start][end] = m[start][start] + m[start+1][end] + p[start-1] * p[start] * p[end];
            //赋一个初值，便于后面的比较，也是第一种情况，k = i；
            for(int cut = start + 1; cut < end; cut++){
                int tmp = m[start][cut] + m[cut+1][end] + p[start-1] * p[cut] * p[end];
                if(tmp < m[start][end]){ // 维护一个最小值 作为最后的m[start][end]
                    m[start][end] = tmp;
                }
            }
        }
    }
}
```


### 最长公共子序列

* 问题描述：若给定序列X={x1 x2 ，...，xm}，则另一序列Z={z1， z 2，...，zk}是X的子序列，是指存在一个严格递增下标序列 {i1， i2，...，ik }，使得对于所有 j=1,2,...,k，有：z j  = x ij 。
    * 如：序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的子序列，相应的递增下标序列为{2，3，5，7}。
    * 给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。
    * 若序列Z有最长的长度，则称Z是序列X和Y的最长公共子序列。
    ---
    | 序列 | 元素 |
    | :-: | :-: |
    | X   | { A, B, C, B, D, A, B } |
    | Y   | { B, D, C, A, B, A } |
    | Z1  | { B, C, A } |
    | Z2  | { B, C, B, A } |
    ---

* 题目求解步骤：
    * 分解最优解的结构
        * 对X={x1，x2 ，...，xm}与Y={y1，y2 ，...，yn}，有最长公共子序列Z={z1，z2 ，...，zk}
            * 若Xm=Yn，则Zk=Xm=Yn，则Zk-1是Xm-1和Yn-1的最长公共子序列
            * 若Xm！=Yn，且Zk！=Xm，则Z是Xm-1和Y的最长公共子序列
            * 若Xm！=Yn，且Zk！=Yn，则Z是X和Yn-1的最长公共子序列
    * 状态转移方程
        * c[i][j]=k：X序列到第i个，Y序列到第j个，最长公共子序列长度为k，则有
---
| 条件                   | 表达式                           |
|------------------------|----------------------------------|
| \( i = 0 \) 或 \( j = 0 \)      | \( c[i][j] = 0 \)                  |
| \( i, j > 0 \) 且 \( Xi = Yj \)  | \( c[i][j] = c[i-1][j-1] + 1 \)    |
| \( i, j > 0 \) 且 \( Xi != Yj \) | \( c[i][j] = max(c[i][j-1], c[i-1][j]) \) |
---
    
   * 计算最优值
---
| 序列 | 元素                  |
| :-:  | :-:                   |
| X    | { A, B, C, B, D, A, B } |
| Y    | { B, D, C, A, B, A }   |
| Z2   | { B, C, B, A }         |
---
* XY最长公共子序列表格
    * x1 和 y4相等   +1
    * x2 和 y5相等   +1
---
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|---|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 1 | 1 | 2 | 2 |
| 3 | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| 4 | 0 | 1 | 1 | 2 | 2 | 3 | 3 |
| 5 | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| 6 | 0 | 1 | 2 | 2 | 3 | 3 | 4 |
| 7 | 0 | 1 | 2 | 2 | 3 | 4 | 4 |
---

* 最长公共子序列代码
```c
int n, m;
char a[Maxn];
char b[Maxn];
int dp[Maxn][Maxn];//dp[i][j] 表示a串的前i个 与b串的前j个  这两个串的最长公共子序列的值

void func(){
    //初始化 i=0表示a串为空串和b串去匹配，则dp值为0，j=0同理
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= m; j++)
            dp[i][j] = 0;
    
    for( int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(a[i] == b[j])//如果i j匹配，取a b串规模更小的最优值+1
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);//否则，a或b缩小规模，取两者更优值
        }
    }
    }
}
```


### 最大子段和

* 问题描述: 给定由n个整数（可能为负整数）组成的序列a1, a2, ..., an，求该序列的形如(s(i,j)=ai + ai+1 + ... aj, 1<=i<=j<=n)的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。最优值为：max{0, max{s(i,j), 1<=i<=j<=n}}。
    * 如：序列（-2，11，-4，13，-5，-2），最大子段和为20。
    * 解决方法有：暴力算法、分治算法、动态规划
    * 先看暴力算法,时间复杂度为O（n^3）


|   |   |   |   |   |   |
|---|---|---|---|---|---|
| -1 | 11 | -4 | 13 | -5 | -2 |

* 暴力算法：枚举所有子段和
```c
// 功能：寻找给定数组中的最大子数组和及其起始和结束索引
void best(int n, int a[]) {
    int sum = 0; // 用于记录最大子数组和
    int besti = 0, bestj = 0; // 用于记录最大子数组的起始和结束索引
    int this_sum; // 用于计算当前子数组和

    // 外层循环，遍历所有可能的起始索引
    for (int i = 1; i <= n; i++) {
        this_sum = 0; // 每次外层循环开始，重置当前子数组和
        // 内层循环，遍历从当前起始索引 i 到 n 的所有结束索引
        for (int j = i; j <= n; j++) {
            this_sum += a[j]; // 累加当前子数组和
            // 如果当前子数组和大于之前记录的最大子数组和
            if (this_sum > sum) {
                sum = this_sum; // 更新最大子数组和
                besti = i; // 更新起始索引
                bestj = j; // 更新结束索引
            }
        }
    }
}

```

* 分治算法 :时间复杂度为O(nlogn)
* 将序列a[1:n]，分为长度相当的两段a[1:n/2]和a[n/2+1:n]，分别求出这两个子段的最大子段和，则序列a[1:n]的最大子段和有三种情形：
    * (1)a[1:n]的最大子段和与a[1:n/2]的最大子段和相同；（在左边）
    * (2)a[1:n]的最大子段和与a[n/2+1:n]的最大子段和相同；（在右边）
    * (3)a[1:n]的最大子段和为s(i,j), 1<=i<=n/2, n/2+1<=j<=n；（在中间）
```c
int max_sum_dac(int a[], int left, int right) {
    // 当前递归的最大和
    int sum = 0;  
    
    // 基本情况：只有一个元素
    if (left == right) {
        return a[left] > 0 ? a[left] : 0; // 返回该元素或0
    }

    // 不止有一个元素
    int center = (left + right) / 2; // 取中心
    int left_sum = max_sum_dac(a, left, center); // 递归找左边的最大和
    int right_sum = max_sum_dac(a, center + 1, right); // 递归找右边的最大和

    int s1 = 0, s2 = 0, tmp = 0;

    // 计算跨越中心的最大和，从中心向左
    for (int i = center; i >= left; i--) {
        tmp += a[i];
        if (tmp > s1) 
            s1 = tmp; // 更新左侧最大和
    }
    
    tmp = 0; // 重置临时和

    // 计算跨越中心的最大和，从中心向右
    for (int j = center + 1; j <= right; j++) {
        tmp += a[j];
        if (tmp > s2)
            s2 = tmp; // 更新右侧最大和
    }

    // 当前段的最大和为左右最大和加起来
    sum = s1 + s2;

    // 返回三个可能的最大和中的最大值
    if(sum < left_sum) sum = left_sum;
    if(sum < right_sum) sum = right_sum;
    return sum;
}

```

* 动态规划
    * 若记b[j]=max{a(i,j), 1<=i<=j}，1<=j<=n，则所求最大子段和为：max{b[j], 1<=j<=n}。
    * 由b[j]的定义，当b[j-1]>0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。
    * 由此，可得状态转移方程：b[j]=max{b[j-1]+a[j], a[j]}, 1<=j<=n。
```c
int best_dp(int n, int a[]) {
    int b[maxN] = {0}; // 动态规划数组，初始化为0

    // 用于记录最大子数组和
    int max_sum = 0; 
    
    for (int i = 1; i <= n; i++) {
        // 更新当前以 a[i] 结尾的最大子数组和
        b[i] = max(b[i-1] + a[i], a[i]); // 如果 b[i-1] < 0，则从当前 a[i] 开始新子数组
        
        // 更新全局最大和
        if (b[i] > max_sum) {
            max_sum = b[i];
        }
    }
    return max_sum; // 返回最大子数组和
}
```



### 01背包

* 问题描述:有n个重量分别为w={w_1,w_2,...,w_n}的物品，他们的价值分别为v={v_1,v_2,...,v_n}，给定一个容量为c的背包。 设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，并且背包内物品的总价值达到最大。
  
| 物品编号 | 1  | 2  | 3  | 4  | 5  |
| :------: | :-: | :-: | :-: | :-: | :-: |
| 重量     | 5  | 10 | 7  | 3  | 5  |
| 价值     | 13 | 9  | 11 | 4  | 4  |

* 状态转移方程
    * 设 f(i ,j) 表示前 i 个物品，体积不超过 j 的情况下可以获得的最大价值。
    * 对于第 i 个物品，有两种选择：
        * 1.不放入背包，此时背包的最大价值为 f (i − 1 , j) ;
        * 2.放入背包，此时背包的最大价值为 f (i − 1 , j − vi) + wi
    * 综上 f(i, j) = max( f(i-1, j), f(i-1 , j - vi) + wi )

    * 规定：
        * 背包容量为10
        * dp[i][j]:表示前 i  个物品，剩余重量为c（重量不超过c） 的情况下可以获得的最大价值

| 条件                        | 表达式                                     |
|-----------------------------|--------------------------------------------|
| \( i = 0 \) 或 \( c = 0 \)     | \( dp[i][c] = 0 \)                        |
| \( wi > c \)               | \( dp[i][c] = dp[i-1][c] \) （不可放）     |
| \( wi <= c \)            | \( dp[i][c] = max(dp[i-1][c], dp[i-1][c-wi] + vi) \) （可放，但要进行选择） |


| 物品 | 1 | 2 | 3 |
| :-:  |:-:|:-:|:-:|
| 体积 | 3 | 4 | 5 |
| 价值 | 4 | 5 | 6 |

* dp表格
    * 每个单元格 dp[i][r] 表示在容量为 r 的情况下，前 i 个物品可以得到的最大价值。
    * 行：每一行代表物品的数量，从 0 到 3，分别对应物品 1、2、3。
    * 列：每一列代表背包的容量（0 到 10）。

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|---|---|----|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0  | 0  |
| 1 | 0 | 0 | 0 | 4 | 4 | 4 | 4 | 4 | 4 | 4  | 4  |
| 2 | 0 | 0 | 0 | 4 | 5 | 5 | 5 | 9 | 9 | 9  | 9  |
| 3 | 0 | 0 | 0 | 4 | 5 | 6 | 6 | 9 | 10 | 11 | 11 |

* 01背包动规代码

```c
int n, c; // n: 物品数量, c: 背包容量
int weight[maxN]; // 物品重量数组
int value[maxN]; // 物品价值数组
int dp[maxN][maxN]; // 动态规划数组

void dp01_func() {
    // 初始化动态规划表
    for (int i = 0; i <= n; i++)
        dp[i][0] = 0; // 背包容量为0时，价值为0
    for (int i = 0; i <= c; i++)
        dp[0][i] = 0; // 物品数量为0时，价值为0
    
    // 动态规划计算
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= c; j++) {
            if (weight[i] > j) {
                dp[i][j] = dp[i - 1][j]; // 当前物品放不下，继承前一个状态
            } else {
                // 选择放入物品或不放入物品
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
}

```



### 最长公共子序列(LCS)

* 题目描述: 给定两个字符串(或数字序列)A和B,求一个字符串,使得这个字符串是A和B的最长公共部分(子序列可以不连续)
    * 样例:
 
| 字符位置 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  |
| -------- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| A        | s  | a  | d  | s  | t  | o  | r  | y  |    |
| B        | a  | d  | m  | i  | n  | s  | o  | r  | y  |
| LCS      | a  | d  | s  | o  | r  | y  |    |    |    |


* 题目求解步骤:
    * 比较a[i] 和 b[j] 有两种情况
    * a[i] = b[j], 则 lcs应为lcs(a[1...i-1] 和 b[1...j-1])+1
    * a[i] != b[j] ,则 字符串A的前i位和字符串B的前j位的LCS无法延长,即lcs没有增大, lcs继承为 lcs(a[1...i-1] 和 b[1...j])与lcs(a[1...i] 和 b[1...j-1])中的最大值
    * 假设dp[i][j]表示字符串A的前i位和字符串B的前j位的最长公共子序列(lcs)
    * 状态转移方程
        * dp[i][j] = d[i-1][j-1] + 1,   a[i] = b[j]
        * dp[i][j] = max(dp[i-1][j], dp[i][j-1]),  a[i]!= b[j]
    * 边界: dp[i][0] = dp[0][j] = 0
* LCS_dp 代码

```c
        int lcs_len(int a[], int n, int b[], int m){
            //初始化
            int dp[maxN][maxN];
            for(int i = 0; i <= n; i++)
                dp[i][0] = 0;
            for(int j = 0; j <= m; j++)
                dp[0][j] = 0;
            //比较a[i] 和b[j]
            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= m; j++){
                    if(a[i] == b[j])
                        dp[i][j] = dp[i-1][j-1] + 1;    //相等,lcs+1
                    else
                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]); //lcs没有增大，继承dp[i-1][j], dp[i][j-1]中的最大值
            }
            return dp[n][m]; // 返回最长公共子序列长度
        }
```




