# c计算机算法设计与分析(王晓东)

个人的计算机算法设计与分析记录(c语言)


# 计算机算法设计与分析

## 第二章 : 动态规划

### 动规的概念
* 定义：需要求解问题可以分为多个子问题，若最优解可由子问题的最优解推出，则可先求子问题的最优解，再构造原问题的最优
解。若子问题重复出现，则将其记忆化存储，便于求解相相同子问题，从而减少计算量，最后自底向上，从最终子问题向原问题逐步求解。

* 动规的基本要素：
    * 最优子结构：指问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
    * 重叠子问题：在解决原问题的过程中，每次产生的子问题并不总是新问题，有些子问题被重复计算。

* 动规算法设计步骤：
    * (1)找出最优解的性质，并刻划其结构特征。
    * (2)递归地定义最优值。
    * (3)以自底向上的方式计算出最优值。
    * (4)根据计算最优值时得到的信息，构造最优解。

* 动规与分治的关系：
    * 相同：动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题
    * 区别：1.分治法独立的子问题，而动态规划的子问题不是互相独立的。2.分治是自顶向下的，而动规是自底而上的

* 状态转移方程：
    * 需某一状态下以及该状态下的决策与下一状态之间的函数关系称为状态转移方程，其中函数可以求的是收益、成本或者距离等，求最优解时所对应的函数称之为最优函数。

* 决策：指决策者在处于某一阶段的某种状态时面对下一阶段的状态做出的选择或者决定

* 状态：描述当前决策过程的特征的量，可以是数量、字符等

### 矩阵连乘

* 问题描述：
给定n个矩阵{A1，A2...An}，其中Ai和Ai+1是可乘的，考察这n个矩阵的连乘积A1*A2*...*An。
由于矩阵的乘法满足结合律，故计算矩阵的连乘积有许多不同的计算次序，而不同的计算次序，所需要计算的连乘次数也是不同
的，求解连乘次数最少的矩阵连乘最优次序。

* 题目求解步骤：
    * 假设最优次数从Ak分开，那么总体的次数就可以得到如下的求法
    ```
    A1*A2*.............*Ak  => T1（i*j）
    Ak+1*Ak+2*.............*An => T2（j*l）
    A1*A2*...*An => T1+T2+i*j*l
    ```
    * 递归的向下继续分，可以得到同样的结果
    * 分解最优解的结构：
    ```
    • 对于矩阵连乘问题，最优解就是找到一种加括号方法，使得计算次数最少。
    • 令m[i][j]表示第i个矩阵至第j个矩阵这段的最优解（这段的最少计算次数）。
    • 将矩阵连乘积记为A[i:j] ，这里i<=j，假设这个最优解在第k处断开，i<=k<j，则A[i:j]是最优的，那么A[i,k]和A[k+1:j]也是相应矩阵连乘的最优解。
    ```
    * 状态转移方程：
    ```
    • 设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] 。
    • 当i=j时，m[i,j]=0;(表示只有一个矩阵,没有和其他矩阵相乘,故乘的次数为0)
    • 当i<j时，m[i,j]=min{m[i,k]+m[k+1,j] +(pi-1)*pk*pj} ,其中 i<=k<j（表示左右乘出来的矩阵最后相乘）
    • 计算最优值
    对于1≤i≤j≤n不同的有序对(i,j) 对于不同的子问题，因此不同子问题的个数最多只有o(n*n).但是若采用递归求解的话，许多子问题将被重复求解，
    所以子问题被重复求解，这也是适合用动态规划法解题的主要特征之一。
    ```
    * 用一个一维度数组p保存
        * Ai:  pi-1 为行， pi为列

| 矩阵 | A1 | A2 | A3 | A4 | A5 | A6 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 行*列 | 30*35 | 35*15 | 15*5 | 5*10 | 10*20 | 20*25 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 下标   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| 值 | 30 | 35 | 15 | 5 | 10 | 20 | 25 |
---



* A[i:j]完整表格
    * 以A[1:3]举例
        * 1.A1（A2A3）=2625+30*35*5=7875
        * 2.（A1A2）A3=15750+30*15*5=18000
        * A[1:3] = min = 7875

---

|   | 1     | 2     | 3     | 4     | 5     | 6     |
|---|-------|-------|-------|-------|-------|-------|
| 1 | 0     | 15750 | 7875  | 9375  | 11875 | 15125 |
| 2 | 0     | 0     | 2625  | 4375  | 7125  | 10500 |
| 3 | 0     | 0     | 0     | 750   | 2500  | 5375  |
| 4 | 0     | 0     | 0     | 0     | 1000  | 3500  |
| 5 | 0     | 0     | 0     | 0     | 0     | 5000  |
| 6 | 0     | 0     | 0     | 0     | 0     | 0     |
---

* 矩阵连乘代码
```c
void func(){
    //初始化
    for(int i = 1; i <= n; i++)
        m[i][i] = 0;
    //len 表示要矩阵连乘的长度
    for(int len = 2; len <= n; len++){
        //枚举长度为len的矩阵的起点的下标
        for(int start = 1; start <= n-len+1; start++){
            int end = start + len - 1; //end位置下标
            m[start][end] = m[start][start] + m[start+1][end] + p[start-1] * p[start] * p[end];
            //赋一个初值，便于后面的比较，也是第一种情况，k = i；
            for(int cut = start + 1; cut < end; cut++){
                int tmp = m[start][cut] + m[cut+1][end] + p[start-1] * p[cut] * p[end];
                if(tmp < m[start][end]){ // 维护一个最小值 作为最后的m[start][end]
                    m[start][end] = tmp;
                }
            }
        }
    }
}
```


### 最长公共子序列

* 问题描述：若给定序列X={x1 x2 ，...，xm}，则另一序列Z={z1， z 2，...，zk}是X的子序列，是指存在一个严格递增下标序列 {i1， i2，...，ik }，使得对于所有 j=1,2,...,k，有：z j  = x ij 。
    * 如：序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的子序列，相应的递增下标序列为{2，3，5，7}。
    * 给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。
    * 若序列Z有最长的长度，则称Z是序列X和Y的最长公共子序列。
    ---
    | 序列 | 元素 |
    | :-: | :-: |
    | X   | { A, B, C, B, D, A, B } |
    | Y   | { B, D, C, A, B, A } |
    | Z1  | { B, C, A } |
    | Z2  | { B, C, B, A } |
    ---

* 题目求解步骤：
    * 分解最优解的结构
        * 对X={x1，x2 ，...，xm}与Y={y1，y2 ，...，yn}，有最长公共子序列Z={z1，z2 ，...，zk}
            * 若Xm=Yn，则Zk=Xm=Yn，则Zk-1是Xm-1和Yn-1的最长公共子序列
            * 若Xm！=Yn，且Zk！=Xm，则Z是Xm-1和Y的最长公共子序列
            * 若Xm！=Yn，且Zk！=Yn，则Z是X和Yn-1的最长公共子序列
    * 状态转移方程
        * c[i][j]=k：X序列到第i个，Y序列到第j个，最长公共子序列长度为k，则有
---
| 条件                   | 表达式                           |
|------------------------|----------------------------------|
| \( i = 0 \) 或 \( j = 0 \)      | \( c[i][j] = 0 \)                  |
| \( i, j > 0 \) 且 \( Xi = Yj \)  | \( c[i][j] = c[i-1][j-1] + 1 \)    |
| \( i, j > 0 \) 且 \( Xi != Yj \) | \( c[i][j] = max(c[i][j-1], c[i-1][j]) \) |
---
    
   * 计算最优值
---
| 序列 | 元素                  |
| :-:  | :-:                   |
| X    | { A, B, C, B, D, A, B } |
| Y    | { B, D, C, A, B, A }   |
| Z2   | { B, C, B, A }         |
---
* XY最长公共子序列表格
    * x1 和 y4相等   +1
    * x2 和 y5相等   +1
---
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|---|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 1 | 1 | 2 | 2 |
| 3 | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| 4 | 0 | 1 | 1 | 2 | 2 | 3 | 3 |
| 5 | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| 6 | 0 | 1 | 2 | 2 | 3 | 3 | 4 |
| 7 | 0 | 1 | 2 | 2 | 3 | 4 | 4 |
---

* 最长公共子序列代码
```c
int n, m;
char a[Maxn];
char b[Maxn];
int dp[Maxn][Maxn];//dp[i][j] 表示a串的前i个 与b串的前j个  这两个串的最长公共子序列的值

void func(){
    //初始化 i=0表示a串为空串和b串去匹配，则dp值为0，j=0同理
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= m; j++)
            dp[i][j] = 0;
    
    for( int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(a[i] == b[j])//如果i j匹配，取a b串规模更小的最优值+1
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);//否则，a或b缩小规模，取两者更优值
        }
    }
    }
}
```


### 最大子段和

* 问题描述: 给定由n个整数（可能为负整数）组成的序列a1, a2, ..., an，求该序列的形如(s(i,j)=ai + ai+1 + ... aj, 1<=i<=j<=n)的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。最优值为：max{0, max{s(i,j), 1<=i<=j<=n}}。
    * 如：序列（-2，11，-4，13，-5，-2），最大子段和为20。
    * 解决方法有：暴力算法、分治算法、动态规划
    * 先看暴力算法,时间复杂度为O（n^3）


|   |   |   |   |   |   |
|---|---|---|---|---|---|
| -1 | 11 | -4 | 13 | -5 | -2 |

* 暴力算法：枚举所有子段和
```c
// 功能：寻找给定数组中的最大子数组和及其起始和结束索引
void best(int n, int a[]) {
    int sum = 0; // 用于记录最大子数组和
    int besti = 0, bestj = 0; // 用于记录最大子数组的起始和结束索引
    int this_sum; // 用于计算当前子数组和

    // 外层循环，遍历所有可能的起始索引
    for (int i = 1; i <= n; i++) {
        this_sum = 0; // 每次外层循环开始，重置当前子数组和
        // 内层循环，遍历从当前起始索引 i 到 n 的所有结束索引
        for (int j = i; j <= n; j++) {
            this_sum += a[j]; // 累加当前子数组和
            // 如果当前子数组和大于之前记录的最大子数组和
            if (this_sum > sum) {
                sum = this_sum; // 更新最大子数组和
                besti = i; // 更新起始索引
                bestj = j; // 更新结束索引
            }
        }
    }
}

```

* 分治算法 :时间复杂度为O(nlogn)
* 将序列a[1:n]，分为长度相当的两段a[1:n/2]和a[n/2+1:n]，分别求出这两个子段的最大子段和，则序列a[1:n]的最大子段和有三种情形：
    * (1)a[1:n]的最大子段和与a[1:n/2]的最大子段和相同；（在左边）
    * (2)a[1:n]的最大子段和与a[n/2+1:n]的最大子段和相同；（在右边）
    * (3)a[1:n]的最大子段和为s(i,j), 1<=i<=n/2, n/2+1<=j<=n；（在中间）
```c
int max_sum_dac(int a[], int left, int right) {
    // 当前递归的最大和
    int sum = 0;  
    
    // 基本情况：只有一个元素
    if (left == right) {
        return a[left] > 0 ? a[left] : 0; // 返回该元素或0
    }

    // 不止有一个元素
    int center = (left + right) / 2; // 取中心
    int left_sum = max_sum_dac(a, left, center); // 递归找左边的最大和
    int right_sum = max_sum_dac(a, center + 1, right); // 递归找右边的最大和

    int s1 = 0, s2 = 0, tmp = 0;

    // 计算跨越中心的最大和，从中心向左
    for (int i = center; i >= left; i--) {
        tmp += a[i];
        if (tmp > s1) 
            s1 = tmp; // 更新左侧最大和
    }
    
    tmp = 0; // 重置临时和

    // 计算跨越中心的最大和，从中心向右
    for (int j = center + 1; j <= right; j++) {
        tmp += a[j];
        if (tmp > s2)
            s2 = tmp; // 更新右侧最大和
    }

    // 当前段的最大和为左右最大和加起来
    sum = s1 + s2;

    // 返回三个可能的最大和中的最大值
    if(sum < left_sum) sum = left_sum;
    if(sum < right_sum) sum = right_sum;
    return sum;
}

```

* 动态规划
    * 若记b[j]=max{a(i,j), 1<=i<=j}，1<=j<=n，则所求最大子段和为：max{b[j], 1<=j<=n}。
    * 由b[j]的定义，当b[j-1]>0时b[j]=b[j-1]+a[j]，否则b[j]=a[j]。
    * 由此，可得状态转移方程：b[j]=max{b[j-1]+a[j], a[j]}, 1<=j<=n。
```c
int best_dp(int n, int a[]) {
    int b[maxN] = {0}; // 动态规划数组，初始化为0

    // 用于记录最大子数组和
    int max_sum = 0; 
    
    for (int i = 1; i <= n; i++) {
        // 更新当前以 a[i] 结尾的最大子数组和
        b[i] = max(b[i-1] + a[i], a[i]); // 如果 b[i-1] < 0，则从当前 a[i] 开始新子数组
        
        // 更新全局最大和
        if (b[i] > max_sum) {
            max_sum = b[i];
        }
    }
    return max_sum; // 返回最大子数组和
}
```



### 01背包

* 问题描述:有n个重量分别为w={w_1,w_2,...,w_n}的物品，他们的价值分别为v={v_1,v_2,...,v_n}，给定一个容量为c的背包。 设计从这些物品中选取一部分物品放入该背包的方案，每个物品要么选中要么不选中，要求选中的物品不仅能够放到背包中，并且背包内物品的总价值达到最大。
  
| 物品编号 | 1  | 2  | 3  | 4  | 5  |
| :------: | :-: | :-: | :-: | :-: | :-: |
| 重量     | 5  | 10 | 7  | 3  | 5  |
| 价值     | 13 | 9  | 11 | 4  | 4  |

* 状态转移方程
    * 设 f(i ,j) 表示前 i 个物品，体积不超过 j 的情况下可以获得的最大价值。
    * 对于第 i 个物品，有两种选择：
        * 1.不放入背包，此时背包的最大价值为 f (i − 1 , j) ;
        * 2.放入背包，此时背包的最大价值为 f (i − 1 , j − vi) + wi
    * 综上 f(i, j) = max( f(i-1, j), f(i-1 , j - vi) + wi )

    * 规定：
        * 背包容量为10
        * dp[i][j]:表示前 i  个物品，剩余重量为c（重量不超过c） 的情况下可以获得的最大价值

| 条件                        | 表达式                                     |
|-----------------------------|--------------------------------------------|
| \( i = 0 \) 或 \( c = 0 \)     | \( dp[i][c] = 0 \)                        |
| \( wi > c \)               | \( dp[i][c] = dp[i-1][c] \) （不可放）     |
| \( wi <= c \)            | \( dp[i][c] = max(dp[i-1][c], dp[i-1][c-wi] + vi) \) （可放，但要进行选择） |


| 物品 | 1 | 2 | 3 |
| :-:  |:-:|:-:|:-:|
| 体积 | 3 | 4 | 5 |
| 价值 | 4 | 5 | 6 |

* dp表格
    * 每个单元格 dp[i][r] 表示在容量为 r 的情况下，前 i 个物品可以得到的最大价值。
    * 行：每一行代表物品的数量，从 0 到 3，分别对应物品 1、2、3。
    * 列：每一列代表背包的容量（0 到 10）。

|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|---|---|---|---|---|---|---|---|---|---|---|----|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0  | 0  |
| 1 | 0 | 0 | 0 | 4 | 4 | 4 | 4 | 4 | 4 | 4  | 4  |
| 2 | 0 | 0 | 0 | 4 | 5 | 5 | 5 | 9 | 9 | 9  | 9  |
| 3 | 0 | 0 | 0 | 4 | 5 | 6 | 6 | 9 | 10 | 11 | 11 |

* 01背包动规代码

```c
int n, c; // n: 物品数量, c: 背包容量
int weight[maxN]; // 物品重量数组
int value[maxN]; // 物品价值数组
int dp[maxN][maxN]; // 动态规划数组

void dp01_func() {
    // 初始化动态规划表
    for (int i = 0; i <= n; i++)
        dp[i][0] = 0; // 背包容量为0时，价值为0
    for (int i = 0; i <= c; i++)
        dp[0][i] = 0; // 物品数量为0时，价值为0
    
    // 动态规划计算
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= c; j++) {
            if (weight[i] > j) {
                dp[i][j] = dp[i - 1][j]; // 当前物品放不下，继承前一个状态
            } else {
                // 选择放入物品或不放入物品
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
}

```



### 最长公共子序列(LCS)

* 题目描述: 给定两个字符串(或数字序列)A和B,求一个字符串,使得这个字符串是A和B的最长公共部分(子序列可以不连续)
    * 样例:
 
| 字符位置 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  |
| -------- | -- | -- | -- | -- | -- | -- | -- | -- | -- |
| A        | s  | a  | d  | s  | t  | o  | r  | y  |    |
| B        | a  | d  | m  | i  | n  | s  | o  | r  | y  |
| LCS      | a  | d  | s  | o  | r  | y  |    |    |    |


* 题目求解步骤:
    * 比较a[i] 和 b[j] 有两种情况
    * a[i] = b[j], 则 lcs应为lcs(a[1...i-1] 和 b[1...j-1])+1
    * a[i] != b[j] ,则 字符串A的前i位和字符串B的前j位的LCS无法延长,即lcs没有增大, lcs继承为 lcs(a[1...i-1] 和 b[1...j])与lcs(a[1...i] 和 b[1...j-1])中的最大值
    * 假设dp[i][j]表示字符串A的前i位和字符串B的前j位的最长公共子序列(lcs)
    * 状态转移方程
        * dp[i][j] = d[i-1][j-1] + 1,   a[i] = b[j]
        * dp[i][j] = max(dp[i-1][j], dp[i][j-1]),  a[i]!= b[j]
    * 边界: dp[i][0] = dp[0][j] = 0
* LCS_dp 代码

```c
        int lcs_len(int a[], int n, int b[], int m){
            //初始化
            int dp[maxN][maxN];
            for(int i = 0; i <= n; i++)
                dp[i][0] = 0;
            for(int j = 0; j <= m; j++)
                dp[0][j] = 0;
            //比较a[i] 和b[j]
            for(int i = 1; i <= n; i++)
                for(int j = 1; j <= m; j++){
                    if(a[i] == b[j])
                        dp[i][j] = dp[i-1][j-1] + 1;    //相等,lcs+1
                    else
                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]); //lcs没有增大，继承dp[i-1][j], dp[i][j-1]中的最大值
            }
            return dp[n][m]; // 返回最长公共子序列长度
        }
```


## 第三章:贪心

### 贪心的概念

* 定义: 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。

* 基本要素: 
    * 贪心选择性质:指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。）
    * 最优子结构性质:当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
* 贪心与动态规划的区别：
    * 不同：
        * 贪心：局部最优出发；动态规划:整体出发。
        * 贪心：只需要保留当前解的前一个解；动态规划：保留全部解。
    * 相同:
        * 贪心算法和动态规划算法都要求问题具有最优子结构性质。 


### 活动安排问题

* 问题描述:设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si < fi。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交,则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。

* 思考:
    * 按照一定的顺序选择相容活动，并能够安排尽量多的活动。有以下两种看似合理的贪心策略：
    * (1)最早开始时间：这样可以增大资源的利用率。 
    * (2)最早结束时间：这样可以使下一个活动尽早开始。
    * 由于活动占用资源的时间没有限制，因此直观上，按最早结束时间这种策略选择相容活动可以留下尽可能多的时间安排更多活动。

| 活动编号 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 |
| :------: | :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:|
| 开始时间 | 1  | 3  | 0  | 5  | 3  | 5  | 6  | 8  | 8  | 2  | 12 |
| 结束时间 | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 15 |

* 贪心选择：
    * 从头开始依次选择，第一个活动一定进行选择，以前一个活动的结束时间end最为参考标准，如果下一个活动的开始时间start>=end，那么就将其纳入相容活动集合，否则不断向后，直至结束。

* 结构体排序
```c
typedef struct {
    int i;
    int j;
}node;
node arr[maxN];
int n; 

bool cmp1(node a, node b){
//调用这个函数会使得数组按照i从小到大进行排序
    return a.i < b.i;
}
sort(arr, arr + n, cmp1);

bool cmp(node a, node b){
//调用这个函数会使得数组按照i从大到小进行排序
    return a.i > b.i;
}
sort(arr, arr + n, cmp2);
```

* 活动安排问题代码

```c
#include <iostream>
#include <algorithm> // 包含 std::sort
using namespace std;

typedef struct {
    int id;    // 活动的唯一标识符
    int s;     // 活动的开始时间
    int f;     // 活动的结束时间
    int flag;  // 标记该活动是否被选中
} activity;

// 比较函数，用于按结束时间排序
bool cmp(activity a, activity b) {
    return a.f < b.f; // 按结束时间升序排列
}

// 函数：选择活动
void func(activity arr[], int n) {
    // 按结束时间排序
    sort(arr, arr + n, cmp);

    int endtime = 0; // 记录上一个被选中活动的结束时间

    // 选择活动
    for (int i = 0; i < n; i++) {
        if (arr[i].s >= endtime) { // 如果当前活动的开始时间大于等于上一个活动的结束时间
            arr[i].flag = 1; // 标记为被选中
            endtime = arr[i].f; // 更新结束时间
        } 
    }

    // 输出被选中的活动的 ID
    for (int i = 0; i < n; i++) {
        if (arr[i].flag) 
            printf("%d ", arr[i].id); // 打印 ID
    }
}

```

### 最优装载问题

* 问题描述:
    * 有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。 最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。

* 贪心选择:
    * 集装箱的重量越小我们就越先装入，即按照重量从小到大进行排序

```c
typedef struct {
    int id; // 盒子的唯一标识符
    int w;  // 盒子的重量
    int flag; // 用于标记是否被选中
} box;

// 比较函数，用于按重量升序排列
bool cmp(box a, box b) {
    return a.w < b.w;
}

// 函数：选择不超过容量 c 的盒子
void func(box arr[], int n, int c) {
    sort(arr, arr + n, cmp); // 按重量升序排序

    int weight = 0; // 当前总重量
    for (int i = 0; i < n; i++) {
        if (weight + arr[i].w <= c) { // 检查是否能放入当前盒子
            arr[i].flag = 1; // 标记为被选中
            weight += arr[i].w; // 更新总重量
        } else {
            break; // 超过容量，停止选择
        }
    }
    for (int i = 0; i < n; i++) {
        if (arr[i].flag) {
            printf("%d ", arr[i].id); // 输出选中盒子的 ID
        }
    }
}


```

### 哈夫曼树
- 参考 https://blog.csdn.net/chenlong_cxy/article/details/117929139
* 哈夫曼树的基本概念
    * 路径: 在一棵树中，从一个结点往下可以达到的结点之间的通路，称为路径
    * 路径长度: 某一路径所经过的“边”的数量，称为该路径的路径长度
    * 带权路径长度: 若将树中结点赋给一个带有某种含义的数值，则该数值称为该结点的权。从根结点到该结点之间的路径长度与该结点的权的乘积，称为该结点的带权路径长度。
    * 树的带权路径长度: 树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。

* 什么是哈夫曼树
    * 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，则称该二叉树为哈夫曼树，也被称为最优二叉树。

* 贪心选择
    * 根据树的带权路径长度的计算规则，我们应该尽可能地让权值大的叶子结点靠近根结点，让权值小的叶子结点远离根结点，这样便能使得这棵二叉树的带权路径长度达到最小。

* 哈夫曼树的构造
    * 1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。
    * 2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。
    * 3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。
    * 4）重复步骤2）和3），直至F中只剩下一棵树为止。

* 总结一下: 
    * 构建哈夫曼树就是反复选择两个最小的元素进行合并，直到只剩下一个元素为止。（贪心策略）

```c
#define N 30
#define M 2*N - 1;
typedef struct HTNode{
    double weight;  //权值
    int parent;  //父节点
    int lc, rc;  //左右孩子
}HTNode, HuffmanTree[M+1];

//在ht[1]至ht[n]的内选择两个parent为0且weight最小的结点，其序号分别赋给s1，s2, s1 < s2
void Select(HuffmanTree ht, int n, int &s1, int &s2){
    int min1 = MAX, min2 = MAX;
    s1 = 0, s2 = 0;
    for(int i = 1; i <= n; i++){
        if(ht[i].parent == 0){  //检查其父结点是否为 0（即它尚未被合并到其他结点中）
            if(ht[i].weight < min1){   //  w < min1
                min2 = min1;      //当前结点的权重小于 min1，则更新 min2 为 min1，
                s2 = s1;            //同时更新 s2 为 s1
                min1 = ht[i].weight;   //然后将 min1 更新为当前结点的权重
                s1 = i;                //并将 s1 更新为当前结点的索引。
            }
            else if(ht[i].weight < min2){ //  当前结点的权重介于 min1 和 min2 之间（即小于 min2）
                min2 = ht[i].weight;   //      则更新 min2 和 s2。
                s2 = i;
            } 
        }
    }
}

//创建huffman树，w[]存放n个权值
void CreateHuff(HuffmanTree ht, int w[], int n){
    int m = 2 * n - 1; //哈夫曼树总节点数
    for(int i = 1; i <= n; i++){
        ht[i].weight = w[i];
        ht[i].parent = 0;
        ht[i].lc = 0;
        ht[i].rc = 0;
    }
    for(int i = n+1; i <= m; i++){
        ht[i].weight = 0;
        ht[i].parent = 0;
        ht[i].lc = 0;
        ht[i].rc = 0;
    }
//初始化结束，开始合并
    for( int i = n+1; i <= m; i++){   //创建非叶结点，建哈夫曼树
        Select(ht, i-1, s1, s2);        //在ht[1]至ht[i-1]的范围内选择两个parent为0
                                        //且weight最小的结点，其序号分别赋给s1，s2
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[i].lc = s1;
        ht[i].rc = s2;
        ht[s1].parent = i;
        ht[s2].parent = i;
    }
}

```


### 单源最短路径

* 题目描述：给定一个图（有向图或者无向图都可以），如何计算图上指定结点到其他所有结点的最短距离？(单源点的最短路径问题)
* 单源点的最短路径问题：给定带权有向图G和源点v0, 求从v0到G中其余各顶点的最短路径。
* 松弛操作 : 
    * 假设A -> B的路线距离为 x, B -> C的路线距离为y，如果直接从A -> C的距离z > x + y，那么先走A -> B，再走B -> C，要比直接从A -> C短. 因此，我们可以借助B缩短AC之间的距离。

* 贪心策略
    * 1. 从起点出发，选择一个距离起点距离最小的、未被标记的顶点；
    * 2. 利用该顶点，对起点到其他所有的顶点进行松弛操作；
    * 3. 标记该顶点已经是最优，重复1、2操作直到没有顶点可以选择。

* 算法思想：
    * 1. 设有两个顶点集合S和T，集合S中存放图中已找到最短路径的顶点，集合T存放图中剩余顶点。初始状态时，集合S中只包含源点v0；
    * 2. 不断从集合T中选取到顶点v0路径长度最短的顶点vi并入到集合S中。
    * 3. 集合S每并入一个新的顶点vi，如果源点v0通过中转顶点vi到集合T中顶点的路径更短，就更新源点v0到集合T中顶点的最短路径长度值。
    * 4. 重复2,3操作，直到集合T的顶点全部并入到S中为止

```c
//Dijkstra算法是解决单源最短路问题的贪心算法，其算法基本思想是:
//    设置顶点集合S并不断的作贪心选择来扩充这个集合
const int maxVexNum = 30; // 最大顶点数量
const int maxInt = 1e4 + 1; // 定义一个很大的值，表示无穷大

// 图的结构体定义
typedef struct {
    int vexNum;  // 顶点数量
    int Edge[maxVexNum][maxVexNum]; // 邻接矩阵
} MGraph;

int visited[maxVexNum];  //标记数组，是否已选进顶点集合
int path[maxVexNum];     //路径数组，记录该点的前一个顶点
int length[maxVexNum];   //长度数组，记录该点到源点V0的距离

void Dijkstra(MGraph G, int v){

    //初始化
    for(int i = 0; i < G.vexNum; i++){
        length[i] = G.Edge[v][i];  // 源点 v 到各个节点的距离
        visited[i] = 0;     // 初始化所有节点未访问
        if(length[i] < maxInt)  path[i] = v;    // 记录前驱节点
        else path[i] = -1;    // maxInt既V0到该顶点之间没有直接路径
    }
    visited[v] = 1;     //v0 加入集合
    path[v] = -1;   // 源点的前驱节点设置为 -1
    length[v] = 0;  // 源点到自己的距离为 0

    // Dijkstra 主循环
    for(int i = 1; i < G.vexNum; i++){
            //遍历n-1次 每次选取一个顶点
        int minm = maxInt;  // 初始化最小距离为无穷大
        int minVex = -1;    // 记录离源点最近的节点
        //每次遍历一轮 查看当前未加入节点，离v0最短的 选入顶点集合
        for(int j = 0; j < G.vexNum; j++){
            if(!visited[j] && length[j] < minm){
                minm = length[j];
                minVex = j;  // 记录最小距离的节点
            }
        }
        visited[minVex] = 1;
        //离v0最短的节点已入集合，开始修改length数组
        //是否有v0源点通过minVex到达的顶点 比 V0直接到达更近
        for(int j = 0; i < G.vexNum; j++){
            if(!visited[j] && dist[minVex] + G.Edge[minVex][j] < length[j])
                //v0->minVex->j 比 当前 v0->j 更近  修改路径数组及长度数组
                length[j] = dist[minVex] + G.Edge[minVex][j];
                path[j] = minVex;
        }
    }
```



