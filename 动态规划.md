# 计算机算法设计与分析

## 第二章 : 动态规划

### 动规的概念
* 定义：需要求解问题可以分为多个子问题，若最优解可由子问题的最优解推出，则可先求子问题的最优解，再构造原问题的最优
解。若子问题重复出现，则将其记忆化存储，便于求解相相同子问题，从而减少计算量，最后自底向上，从最终子问题向原问题逐步求解。

* 动规的基本要素：
    * 最优子结构：指问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
    * 重叠子问题：在解决原问题的过程中，每次产生的子问题并不总是新问题，有些子问题被重复计算。

* 动规算法设计步骤：
    * (1)找出最优解的性质，并刻划其结构特征。
    * (2)递归地定义最优值。
    * (3)以自底向上的方式计算出最优值。
    * (4)根据计算最优值时得到的信息，构造最优解。

* 动规与分治的关系：
    * 相同：动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题
    * 区别：1.分治法独立的子问题，而动态规划的子问题不是互相独立的。2.分治是自顶向下的，而动规是自底而上的

* 状态转移方程：
    * 需某一状态下以及该状态下的决策与下一状态之间的函数关系称为状态转移方程，其中函数可以求的是收益、成本或者距离等，求最优解时所对应的函数称之为最优函数。

* 决策：指决策者在处于某一阶段的某种状态时面对下一阶段的状态做出的选择或者决定

* 状态：描述当前决策过程的特征的量，可以是数量、字符等

### 矩阵连乘

* 问题描述：
给定n个矩阵{A1，A2...An}，其中Ai和Ai+1是可乘的，考察这n个矩阵的连乘积A1*A2*...*An。
由于矩阵的乘法满足结合律，故计算矩阵的连乘积有许多不同的计算次序，而不同的计算次序，所需要计算的连乘次数也是不同
的，求解连乘次数最少的矩阵连乘最优次序。

* 题目求解步骤：
    * 假设最优次数从Ak分开，那么总体的次数就可以得到如下的求法
    ```
    A1*A2*.............*Ak  => T1（i*j）
    Ak+1*Ak+2*.............*An => T2（j*l）
    A1*A2*...*An => T1+T2+i*j*l
    ```
    * 递归的向下继续分，可以得到同样的结果
    * 分解最优解的结构：
    ```
    • 对于矩阵连乘问题，最优解就是找到一种加括号方法，使得计算次数最少。
    • 令m[i][j]表示第i个矩阵至第j个矩阵这段的最优解（这段的最少计算次数）。
    • 将矩阵连乘积记为A[i:j] ，这里i<=j，假设这个最优解在第k处断开，i<=k<j，则A[i:j]是最优的，那么A[i,k]和A[k+1:j]也是相应矩阵连乘的最优解。
    ```
    * 状态转移方程：
    ```
    • 设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n] 。
    • 当i=j时，m[i,j]=0;(表示只有一个矩阵,没有和其他矩阵相乘,故乘的次数为0)
    • 当i<j时，m[i,j]=min{m[i,k]+m[k+1,j] +(pi-1)*pk*pj} ,其中 i<=k<j（表示左右乘出来的矩阵最后相乘）
    • 计算最优值
    对于1≤i≤j≤n不同的有序对(i,j) 对于不同的子问题，因此不同子问题的个数最多只有o(n*n).但是若采用递归求解的话，许多子问题将被重复求解，
    所以子问题被重复求解，这也是适合用动态规划法解题的主要特征之一。
    ```
    * 用一个一维度数组p保存
        * Ai:  pi-1 为行， pi为列

| 矩阵 | A1 | A2 | A3 | A4 | A5 | A6 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 行*列 | 30*35 | 35*15 | 15*5 | 5*10 | 10*20 | 20*25 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 下标   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
| 值 | 30 | 35 | 15 | 5 | 10 | 20 | 25 |
---



* A[i:j]完整表格
    * 以A[1:3]举例
        * 1.A1（A2A3）=2625+30*35*5=7875
        * 2.（A1A2）A3=15750+30*15*5=18000
        * A[1:3] = min = 7875

---

|   | 1     | 2     | 3     | 4     | 5     | 6     |
|---|-------|-------|-------|-------|-------|-------|
| 1 | 0     | 15750 | 7875  | 9375  | 11875 | 15125 |
| 2 | 0     | 0     | 2625  | 4375  | 7125  | 10500 |
| 3 | 0     | 0     | 0     | 750   | 2500  | 5375  |
| 4 | 0     | 0     | 0     | 0     | 1000  | 3500  |
| 5 | 0     | 0     | 0     | 0     | 0     | 5000  |
| 6 | 0     | 0     | 0     | 0     | 0     | 0     |
---

* 矩阵连乘代码
```c
void func(){
    //初始化
    for(int i = 1; i <= n; i++)
        m[i][i] = 0;
    //len 表示要矩阵连乘的长度
    for(int len = 2; len <= n; len++){
        //枚举长度为len的矩阵的起点的下标
        for(int start = 1; start <= n-len+1; start++){
            int end = start + len - 1; //end位置下标
            m[start][end] = m[start][start] + m[start+1][end] + p[start-1] * p[start] * p[end];
            //赋一个初值，便于后面的比较，也是第一种情况，k = i；
            for(int cut = start + 1; cut < end; cut++){
                int tmp = m[start][cut] + m[cut+1][end] + p[start-1] * p[cut] * p[end];
                if(tmp < m[start][end]){ // 维护一个最小值 作为最后的m[start][end]
                    m[start][end] = tmp;
                }
            }
        }
    }
}
```


### 最长公共子序列

* 问题描述：若给定序列X={x1 x2 ，...，xm}，则另一序列Z={z1， z 2，...，zk}是X的子序列，是指存在一个严格递增下标序列 {i1， i2，...，ik }，使得对于所有 j=1,2,...,k，有：z j  = x ij 。
    * 如：序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的子序列，相应的递增下标序列为{2，3，5，7}。
    * 给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。
    * 若序列Z有最长的长度，则称Z是序列X和Y的最长公共子序列。
    ---
    | 序列 | 元素 |
    | :-: | :-: |
    | X   | { A, B, C, B, D, A, B } |
    | Y   | { B, D, C, A, B, A } |
    | Z1  | { B, C, A } |
    | Z2  | { B, C, B, A } |
    ---

* 题目求解步骤：
    * 分解最优解的结构
        * 对X={x1，x2 ，...，xm}与Y={y1，y2 ，...，yn}，有最长公共子序列Z={z1，z2 ，...，zk}
            * 若Xm=Yn，则Zk=Xm=Yn，则Zk-1是Xm-1和Yn-1的最长公共子序列
            * 若Xm！=Yn，且Zk！=Xm，则Z是Xm-1和Y的最长公共子序列
            * 若Xm！=Yn，且Zk！=Yn，则Z是X和Yn-1的最长公共子序列
    * 状态转移方程
        * c[i][j]=k：X序列到第i个，Y序列到第j个，最长公共子序列长度为k，则有
---
| 条件                   | 表达式                           |
|------------------------|----------------------------------|
| \( i = 0 \) 或 \( j = 0 \)      | \( c[i][j] = 0 \)                  |
| \( i, j > 0 \) 且 \( Xi = Yj \)  | \( c[i][j] = c[i-1][j-1] + 1 \)    |
| \( i, j > 0 \) 且 \( Xi != Yj \) | \( c[i][j] = max(c[i][j-1], c[i-1][j]) \) |
---
    
   * 计算最优值
---
| 序列 | 元素                  |
| :-:  | :-:                   |
| X    | { A, B, C, B, D, A, B } |
| Y    | { B, D, C, A, B, A }   |
| Z2   | { B, C, B, A }         |
---
* XY最长公共子序列表格
    * x1 和 y4相等   +1
    * x2 和 y5相等   +1
---
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|---|
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 2 | 0 | 1 | 1 | 1 | 1 | 2 | 2 |
| 3 | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| 4 | 0 | 1 | 1 | 2 | 2 | 3 | 3 |
| 5 | 0 | 1 | 2 | 2 | 2 | 3 | 3 |
| 6 | 0 | 1 | 2 | 2 | 3 | 3 | 4 |
| 7 | 0 | 1 | 2 | 2 | 3 | 4 | 4 |
---

* 最长公共子序列代码
```c
int n, m;
char a[Maxn];
char b[Maxn];
int dp[Maxn][Maxn];//dp[i][j] 表示a串的前i个 与b串的前j个  这两个串的最长公共子序列的值

void func(){
    //初始化 i=0表示a串为空串和b串去匹配，则dp值为0，j=0同理
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= m; j++)
            dp[i][j] = 0;
    
    for( int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(a[i] == b[j])//如果i j匹配，取a b串规模更小的最优值+1
                dp[i][j] = dp[i-1][j-1] + 1;
            else
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);//否则，a或b缩小规模，取两者更优值
        }
    }
    }
}
```


### 最大子字段和

* 问题描述: 给定由n个整数（可能为负整数）组成的序列a1, a2, ..., an，求该序列的形如(s(i,j)=ai + ai+1 + ... aj, 1<=i<=j<=n)的子段和的最大值。当所有整数均为负整数时定义其最大子段和为0。最优值为：max{0, max{s(i,j), 1<=i<=j<=n}}。
    * 如：序列（-2，11，-4，13，-5，-2），最大子段和为20。
    * 解决方法有：暴力算法、改进后的暴力算法、分治算法、动态规划
    * 先看暴力算法,时间复杂度为O（n^3）


|   |   |   |   |   |   |
|---|---|---|---|---|---|
| -1 | 11 | -4 | 13 | -5 | -2 |

    


